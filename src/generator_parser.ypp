%{

#include <stdio.h>
#include <math.h>
#include <stdexcept>
#include <sstream>

extern "C" {
#include "generator_scanner.h"
}

#include "generator.h"

extern int yyerror(Parser * ptr, const char *s);
extern "C" int yyget_lineno  (void);

%}
%union {
  char * str;
  double number;
}
%parse-param { Parser * ptr }
%token NAME
%token PRECISSION
%token METHOD
%token SURFACE
%token APPROXIMATION
%token MAP
%token SCALAR
%token FUNCTION
%token EQUATION
%token JACOBIAN
%token DELTA
%token ARROW
%token <str> VAR
%token <num> NUMBER
%right '='
%left '+' '-'
%left '*' '/'
%right '^'
%%

body: '\n'
	| clause '\n'
	| body '\n'
	| body clause '\n'
	;

clause: 
	NAME ':' VAR { fprintf(stderr, "name: %s\n", yytext); }
	| PRECISSION ':' VAR { fprintf(stderr, "precission: %s\n", yytext); }
	| METHOD ':' VAR { fprintf(stderr, "method: %s\n", yytext); }
	| SURFACE ':' VAR { fprintf(stderr, "surface: %s\n", yytext); }
	| APPROXIMATION ':' VAR { fprintf(stderr, "apporox: %s", yytext); }
	| MAP ':' VAR ARROW VAR {}
	| SCALAR ':' VAR {}
	| FUNCTION ':' VAR {}
	| FUNCTION ':' VAR '(' VAR ',' VAR ')' {}
	| FUNCTION ':' VAR '(' VAR ',' VAR ',' VAR ')' {}
	| EQUATION ':' expr {}
	;

expr: VAR {}
	| NUMBER {}
	| VAR '[' NUMBER ']' {}
	| '(' expr ')' {}
	| expr '^' expr {}
	| expr '_' expr {}
	| expr '+' expr {}
	| expr '-' expr {}
	| expr '/' expr {}
	| expr '*' expr {}
	| function expr {}
	| expr '=' expr {}
	;

function: JACOBIAN {}
	| DELTA {}
	;
%%
int yyerror(Parser * ptr, const char * s)
{
	std::stringstream str;
	str << "syntax error near line " << yyget_lineno() << "\n";
	ptr->error = true;
	throw std::logic_error(str.str());
	return 0;
}
