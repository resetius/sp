%{

#include <stdio.h>
#include <math.h>
#include <stdexcept>
#include <sstream>
#include <memory>

#define YY_DECL int yylex( YYSTYPE & yylval )

#include "generator_scanner.h"
#include "generator.h"

extern int yyerror(Parser * ptr, const char *s);

using namespace std;

%}
%union {
	char * str;
	double num;
	struct Expression * exp;
}
%parse-param { Parser * ptr }
%define api.pure
%define api.push_pull "push"
%token NAME
%token PRECISSION
%token METHOD
%token SURFACE
%token APPROXIMATION
%token START
%token DECLARE
%token SCALAR
%token FUNCTION
%token EQUATION
%token JACOBIAN
%token DELTA
%token ARROW
%token <str> VAR
%token <num> NUMBER
%type  <exp> expr;
%type  <exp> sexpr;
%type  <exp> operator;
%right '='
%left '+' '-'
%left '*' '/'
%left ','
%right '^'
%destructor { fprintf(stderr, "destroy %s\n", $$); free($$); } <str>
%%

body: '\n'
	| clause '\n'
	| body '\n'
	| body clause '\n'
	;

clause: 
	NAME ':' VAR 
		{
			string arg = $3; free($3);
			ptr->set_name(arg); 
		}
	| PRECISSION ':' VAR 
		{
			string arg = $3; free($3);
			ptr->set_precission(arg); 
		}
	| METHOD ':' VAR 
		{
			string arg = $3; free($3);
			ptr->set_method(arg); 
		}
	| SURFACE ':' VAR 
		{
			string arg = $3; free($3); 
			ptr->set_surface(arg); 
		}
	| APPROXIMATION ':' VAR 
		{
			string arg = $3; free($3);
			ptr->set_approximation(arg); 
		}
	| START ':' VAR 
		{
			string arg = $3; free($3);
			ptr->add_initial(arg); 
		}
	| DECLARE ':' VAR '=' expr
		{
			string arg = $3; free($3);
			ptr->add_declaration(arg, $5);
		}
	| SCALAR ':' VAR
		{
			string var = $3;
			free($3);
			ptr->add_scalar(var); 
		}
	| FUNCTION ':' VAR '(' VAR ',' VAR ')' 
		{
			string arg = $3;
			free($3); free($5); free($7); 
			ptr->add_function(arg, 2); 
		}
	| FUNCTION ':' VAR '(' VAR ',' VAR ',' VAR ')' 
		{
			string arg = $3;
			free($3); free($5); free($7); free($9);
			ptr->add_function(arg, 3); 
		}
	| EQUATION ':' expr '=' expr { ptr->add_equation($3, $5); }
	;

expr:
	VAR 
		{
			$$    = ptr->new_expression();
			ptr->check_var($1);
			*($$) = $1;
			fprintf(stderr, "%s\n", $1); free($1);
		}
	| NUMBER 
		{
			$$    = ptr->new_expression();
			(*$$) = $1;
			fprintf(stderr, "%lf\n", $1); 
		}
	| VAR '[' NUMBER ']' 
		{
			$$    = ptr->new_expression();
			ptr->check_var($1);
			*($$) = $1;
			fprintf(stderr, "%s\n", $1); fprintf(stderr, "%d\n", $3); free($1); 
		}
	| '(' expr ')' { $$ = $2; }
	| expr '^' expr { (*$1) ^= *($3); $$ = $1; }
	| expr '+' expr { (*$1) += *($3); $$ = $1; }
	| expr '-' expr { (*$1) -= *($3); $$ = $1; }
	| expr '/' expr { (*$1) /= *($3); $$ = $1; }
	| expr '*' expr { (*$1) *= *($3); $$ = $1; }
	| operator '(' sexpr ')' 
		{
			(*$1)(*$3); $$ = $1;
		}
	;

sexpr: expr { $$ = $1; }
	| sexpr ',' expr { (*$1) , (*$3); $$ = $1; }
	;
	
operator: JACOBIAN { $$ = ptr->new_expression(); *$$ = "Jacobian"; }
	| DELTA { $$ = ptr->new_expression(); *$$ = "Delta"; }
	;
%%
int yyerror(Parser * ptr, const char * s)
{
	std::stringstream str;
	str << "syntax error near line " << yyget_lineno();
	throw std::logic_error(str.str());
	return 0;
}

int yylex( YYSTYPE & );

void do_parse(Parser * ptr)
{
	int yychar;
	int status;
	yypstate *ps = yypstate_new ();
	try {
		do {
			YYSTYPE val;
			yychar = yylex (val);
			status = yypush_parse (ps, yychar, &val, ptr);
		} while (status == YYPUSH_MORE);
	} catch ( exception & e) {
		yypstate_delete (ps);
		throw;
	}
	yypstate_delete (ps);
}
